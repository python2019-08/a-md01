# 1.target_compile_options

target_compile_options 是 CMake 中的一个重要命令，主要用于为特定的目标（如可执行文件、静态库、动态库等）设置编译选项。下面从基本语法、参数解释、使用示例、作用范围和优先级等方面详细介绍该命令。
## 1.1基本语法
```cmake
target_compile_options(<target> [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
```

### 参数解释
```
* <target>：指定要设置编译选项的目标名称。这个目标必须是之前通过 add_executable、add_library 等命令创建的。
* BEFORE（可选）：如果指定了 BEFORE，则将这些编译选项添加到目标已有编译选项的前面；否则，添加到后面。
* <INTERFACE|PUBLIC|PRIVATE>：
    PRIVATE：这些编译选项仅应用于指定的目标本身，不会传递给依赖该目标的其他目标。
    INTERFACE：这些编译选项不会应用于指定的目标本身，但会传递给依赖该目标的其他目标。通常用于定义接口相关的编译选项。
    PUBLIC：这些编译选项既应用于指定的目标本身，也会传递给依赖该目标的其他目标。
* [items1...]、[items2...] 等：具体的编译选项列表，可以是单个选项，也可以是多个选项的组合。例如，-Wall、-std=c++11 等。
```
## 1.2使用示例
### 1.2.1为可执行文件设置编译选项
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

# 创建可执行文件目标
add_executable(my_app main.cpp)

# 为 my_app 目标设置编译选项
target_compile_options(my_app PRIVATE -Wall -Wextra -std=c++11)
```
在这个示例中，我们为 my_app 可执行文件目标设置了 -Wall（开启所有常见警告）、-Wextra（开启额外警告）和 -std=c++11（使用 C++11 标准）这三个编译选项，并且这些选项仅应用于 my_app 本身。


### 1.2.2为库目标设置接口编译选项
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyLibraryProject)

# 创建静态库目标
add_library(my_lib STATIC lib.cpp)

# 为 my_lib 目标设置接口编译选项
target_compile_options(my_lib INTERFACE -DUSE_FEATURE_X)

# 创建可执行文件目标并链接 my_lib
add_executable(my_app main.cpp)
target_link_libraries(my_app PRIVATE my_lib)
```
在这个示例中，我们为 my_lib 静态库目标设置了接口编译选项 -DUSE_FEATURE_X。这个选项不会应用于 my_lib 本身，但会传递给依赖 my_lib 的 my_app 目标，即 my_app 在编译时会使用 -DUSE_FEATURE_X 选项。

### 1.2.3作用范围和优先级
* 作用范围：target_compile_options 只对指定的目标生效，相比于 CMAKE_CXX_FLAGS 这种全局编译选项，它可以为不同的目标设置不同的编译选项，提供了更细粒度的控制。
* 优先级：当 target_compile_options 和 CMAKE_CXX_FLAGS 同时为某个目标指定编译选项时，target_compile_options 指定的选项优先级更高，会覆盖 CMAKE_CXX_FLAGS 中设置的部分选项。

通过 target_compile_options 命令，你可以灵活地为不同的目标设置个性化的编译选项，从而满足项目的各种需求。

# 2.CMAKE_CXX_FLAGS和target_compile_options的关系
CMAKE_CXX_FLAGS 和 target_compile_options 都与 CMake 项目中 C++ 代码的编译选项相关，但它们在作用范围、使用方式等方面存在一些差异，下面为你详细介绍它们的关系。
## 2.1 共同点
二者的主要目的都是为 C++ 代码指定编译选项，这些编译选项可以影响编译器的行为，例如指定 C++ 标准版本、开启警告信息、进行优化等。

## 2.2不同点
### 2.2.1. 作用范围
(1)CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS 是一个全局变量，它会影响项目中所有 C++ 目标（如可执行文件、静态库、动态库等）的编译选项。一旦在 CMakeLists.txt 文件中设置了 CMAKE_CXX_FLAGS，所有后续创建的 C++ 目标都会使用这些编译选项。
示例代码：
```cmake
# 设置全局 C++ 编译选项
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall")

add_executable(my_app main.cpp)
```

在这个例子中，-std=c++11 -Wall 这两个编译选项会应用到 my_app 这个可执行文件的编译过程中，同时也会影响项目中其他后续创建的 C++ 目标。

(2)target_compile_options
target_compile_options 是一个针对特定目标的命令，它只会影响指定目标的编译选项。你可以为不同的目标设置不同的编译选项，实现更细粒度的控制。

示例代码：
```cmake
add_executable(my_app main.cpp)
# 为 my_app 目标设置编译选项
target_compile_options(my_app PRIVATE -std=c++11 -Wall)

add_library(my_lib STATIC lib.cpp)
# 为 my_lib 目标设置不同的编译选项
target_compile_options(my_lib PRIVATE -std=c++14 -Wextra)
```

在这个例子中，my_app 目标使用 -std=c++11 -Wall 编译选项，而 my_lib 目标使用 -std=c++14 -Wextra 编译选项。
### 2.2.2. 使用灵活性
(1)CMAKE_CXX_FLAGS
虽然使用方便，但缺乏灵活性。如果项目中有多个目标需要不同的编译选项，使用 CMAKE_CXX_FLAGS 就很难实现。而且，一旦设置了全局编译选项，后续修改起来可能会影响到所有目标。
(2)target_compile_options
具有很高的灵活性，可以针对每个目标单独设置编译选项，满足不同目标的特殊需求。同时，在维护代码时，也更容易管理和修改每个目标的编译选项。
### 2.2.3. 优先级
当 CMAKE_CXX_FLAGS 和 target_compile_options 同时为某个目标指定编译选项时，target_compile_options 指定的选项优先级更高。也就是说，target_compile_options 可以覆盖 CMAKE_CXX_FLAGS 中设置的部分选项。

示例代码：
```cmake
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall")

add_executable(my_app main.cpp)
# 为 my_app 目标设置编译选项，覆盖 CMAKE_CXX_FLAGS 中的 -std=c++11
target_compile_options(my_app PRIVATE -std=c++14)
```

在这个例子中，my_app 目标最终会使用 -std=c++14 -Wall 作为编译选项，target_compile_options 中指定的 -std=c++14 覆盖了 CMAKE_CXX_FLAGS 中的 -std=c++11。

## 2.3小结
综上所述，CMAKE_CXX_FLAGS 适用于为项目中的所有 C++ 目标设置通用的编译选项，而 target_compile_options 更适合为特定目标设置个性化的编译选项。在实际项目中，可以根据需要结合使用这两种方式。


# 3.set(CMAKE_CXX_STANDARD 11) 和set(CMAKE_CXX_FLAGS  "-std=c++11")
set(CMAKE_CXX_STANDARD 11) 和 set(CMAKE_CXX_FLAGS "-std=c++11") 都能用于指定 C++ 项目编译时所采用的 C++ 标准版本，但它们在使用方式、工作机制、可移植性和灵活性等方面存在明显差异，下面为你详细剖析。

## 3.1共同点
二者的核心目的一致，都是为了让 C++ 代码在编译过程中遵循 C++11 标准。

## 3.2不同点
### 3.2.1. 使用方式与工作机制
(1)set(CMAKE_CXX_STANDARD 11)
这是 CMake 专门提供的一种较为高级的方式。通过设置 CMAKE_CXX_STANDARD 变量，CMake 会依据当前使用的编译器，自动将其转换为对应的编译选项。举例来说，对于 GCC 和 Clang 编译器，CMake 会自动添加 -std=c++11 选项；对于 Visual Studio 编译器，则会采用合适的方式来启用 C++11 支持。

示例代码：
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

set(CMAKE_CXX_STANDARD 11)
add_executable(my_app main.cpp)
```

(2)set(CMAKE_CXX_FLAGS "-std=c++11")
此方法是直接设置全局的 C++ 编译选项。CMAKE_CXX_FLAGS 是一个存储编译选项的字符串变量，将其设置为 -std=c++11 后，所有后续的 C++ 编译操作都会带上这个选项。不过，这种方式依赖于具体的编译器，因为 -std=c++11 是 GCC 和 Clang 这类编译器所支持的选项，不同编译器可能有不同的选项来指定 C++ 标准。

示例代码：
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

set(CMAKE_CXX_FLAGS "-std=c++11")
add_executable(my_app main.cpp)
```
### 3.2.2. 可移植性
(1)set(CMAKE_CXX_STANDARD 11)
具有良好的可移植性。由于 CMake 会自动处理不同编译器之间的差异，无论使用 GCC、Clang 还是 Visual Studio 等编译器，都能正确地启用 C++11 支持，无需开发者手动针对不同编译器进行调整。
(2)set(CMAKE_CXX_FLAGS "-std=c++11")
可移植性较差。因为 -std=c++11 并非所有编译器都支持，当项目需要在不同的编译器环境中编译时，可能需要手动修改 CMAKE_CXX_FLAGS 中的选项，以适应不同的编译器。
### 3.2.3. 灵活性与优先级
(1)set(CMAKE_CXX_STANDARD 11)
灵活性较高。可以通过为特定目标设置 CXX_STANDARD 属性来覆盖全局的 CMAKE_CXX_STANDARD 设置，实现更细粒度的控制。例如：
```cmake
set(CMAKE_CXX_STANDARD 11)
add_executable(my_app main.cpp)
set_target_properties(my_app PROPERTIES CXX_STANDARD 14)
```
在这个例子中，虽然全局设置为 C++11 标准，但 my_app 目标会使用 C++14 标准进行编译。

(2)set(CMAKE_CXX_FLAGS "-std=c++11")
灵活性相对较低。由于 CMAKE_CXX_FLAGS 是全局变量，一旦设置，所有目标都会受到影响，除非通过其他方式手动为特定目标修改编译选项。不过，target_compile_options 命令指定的选项优先级高于 CMAKE_CXX_FLAGS，可以覆盖其部分设置。

### 3.2.4. 推荐使用场景
(1)set(CMAKE_CXX_STANDARD 11)
推荐在大多数情况下使用，尤其是项目需要在不同编译器环境中进行编译时。它能简化 CMake 脚本的编写，提高项目的可移植性。

(2)set(CMAKE_CXX_FLAGS "-std=c++11")
适用于需要对编译选项进行精细控制，或者项目只在特定编译器环境中编译，且需要使用一些特殊编译选项的情况。
## 3.3小结
综上所述，为了提高项目的可移植性和代码的简洁性，建议优先使用 set(CMAKE_CXX_STANDARD) 来指定 C++ 标准；只有在特殊需求下，才考虑使用 set(CMAKE_CXX_FLAGS)。

# 4.set(CMAKE_CXX_STANDARD 11) 和set(CMAKE_CXX_FLAGS  "-std=c++11")及target_compile_options(my_app PRIVATE -std=c++11)的优先级
在 CMake 中，set(CMAKE_CXX_STANDARD 11)、set(CMAKE_CXX_FLAGS "-std=c++11") 和 target_compile_options(my_app PRIVATE -std=c++11) 都与指定 C++ 编译标准相关，它们的优先级关系如下：
## 4.1优先级顺序
target_compile_options > set(CMAKE_CXX_STANDARD) > set(CMAKE_CXX_FLAGS)
## 4.2详细解释
### 4.2.1. target_compile_options 优先级最高
target_compile_options 用于为特定的目标（如可执行文件、库等）设置编译选项，并且可以通过 PRIVATE、PUBLIC、INTERFACE 来控制选项的作用范围。由于它是直接针对目标进行设置的，所以优先级最高。

示例代码：
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_FLAGS "-std=c++11")

add_executable(my_app main.cpp)
target_compile_options(my_app PRIVATE -std=c++20)
```

在这个例子中，虽然全局设置了 CMAKE_CXX_STANDARD 为 14，CMAKE_CXX_FLAGS 为 -std=c++11，但 my_app 目标会使用 target_compile_options 中指定的 -std=c++20 作为编译标准，因为 target_compile_options 的优先级最高。
### 4.2.2. set(CMAKE_CXX_STANDARD) 优先级次之
set(CMAKE_CXX_STANDARD) 是一种较为高级的设置方式，它会让 CMake 根据不同的编译器自动转换为相应的编译选项。当没有使用 target_compile_options 为特定目标设置编译标准时，CMAKE_CXX_STANDARD 的设置会生效，覆盖 CMAKE_CXX_FLAGS 中关于 C++ 标准的设置。
示例代码：
```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_FLAGS "-std=c++11")

add_executable(my_app main.cpp)
```
在这个例子中，my_app 目标会使用 C++14 标准进行编译，因为 CMAKE_CXX_STANDARD 的优先级高于 CMAKE_CXX_FLAGS。
### 4.2.3. set(CMAKE_CXX_FLAGS) 优先级最低
set(CMAKE_CXX_FLAGS) 是直接设置全局的 C++ 编译选项，它的优先级最低。如果同时存在 CMAKE_CXX_STANDARD 和 target_compile_options 的设置，CMAKE_CXX_FLAGS 中关于 C++ 标准的设置会被覆盖。

## 4.3小结
在实际项目中，如果需要为特定目标设置特殊的编译标准，优先使用 target_compile_options；如果项目中的大部分目标都使用相同的 C++ 标准，建议使用 set(CMAKE_CXX_STANDARD)；而 set(CMAKE_CXX_FLAGS) 通常用于设置一些通用的、不与 C++ 标准冲突的编译选项。这样可以确保编译选项的设置符合预期，提高项目的可维护性和可移植性。


# 5.链接顺序 问题如何解决
当遇到链接顺序问题时，通常是因为链接器在解析符号引用时，按照链接命令中库的顺序进行查找，如果顺序不正确，可能会导致符号无法找到，出现 “undefined reference” 错误。下面为你详细介绍解决链接顺序问题的方法：
## 5.1. 了解链接器查找符号的规则
链接器在解析符号引用时，会按照链接命令中库的顺序依次查找。当遇到一个未定义的符号时，它会在当前库以及后续的库中查找该符号的定义。一旦找到，就会将其链接进来；如果直到最后都没找到，就会报 “undefined reference” 错误。所以，一般来说，被依赖的库要放在依赖它的库之后。
## 5.2. 调整库的链接顺序
### 5.2.1手动调整
在链接命令中，将被依赖的库放在依赖它的库之后。例如，假设 libA.so 依赖 libB.so 和 libC.so，那么链接命令应该如下：
```sh
gcc your_source_files.o -o your_program -L/path/to/libs -lA -lB -lC
```
这里 -lA 是依赖库，-lB 和 -lC 是被依赖库，放在 -lA 之后。
对于你之前遇到的问题，链接命令可以调整为：
```sh
gcc your_source_files.o -o your_program /home/abel/zdev/cpp/cnnavi - i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306 - 24.39.03.00 - CA - 0.53.0/linux/ubuntu64/libs - asan/libmx_sdk.so /home/abel/zdev/cpp/cnnavi - i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306 - 24.39.03.00 - CA - 0.53.0/linux/ubuntu64/libs - asan/libGComm3rd.so /home/abel/zdev/cpp/cnnavi - i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306 - 24.39.03.00 - CA - 0.53.0/linux/ubuntu64/libs - asan/libGNet.so /home/abel/zdev/cpp/cnnavi - i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306 - 24.39.03.00 - CA - 0.53.0/linux/ubuntu64/libs - asan/libmqtt.so -fsanitize=address -lasan -lssl -lcrypto
```

确保 -lasan、-lssl 和 -lcrypto 这些被依赖的库放在其他库之后。
### 5.2.2 使用 CMake 调整
如果你使用 CMake 来管理项目，可以在 CMakeLists.txt 文件中调整 target_link_libraries 的参数顺序。例如：
```cmake
add_executable(your_program your_source_files.cpp)
target_link_libraries(your_program 
    /home/abel/zdev/cpp/cnnavi-i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306-24.39.03.00-CA-0.53.0/linux/ubuntu64/libs-asan/libmx_sdk.so
    /home/abel/zdev/cpp/cnnavi-i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306-24.39.03.00-CA-0.53.0/linux/ubuntu64/libs-asan/libGComm3rd.so
    /home/abel/zdev/cpp/cnnavi-i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306-24.39.03.00-CA-0.53.0/linux/ubuntu64/libs-asan/libGNet.so
    /home/abel/zdev/cpp/cnnavi-i3/NaviCore/3rd/mxnavisdk/mx_sdk_shared/BENZ.03.686306-24.39.03.00-CA-0.53.0/linux/ubuntu64/libs-asan/libmqtt.so
    -fsanitize=address
    -lasan
    -lssl
    -lcrypto
)
```

## 5.3. 循环依赖问题的解决
如果存在库之间的循环依赖（例如 libA.so 依赖 libB.so，而 libB.so 又依赖 libA.so），可以使用 -Wl,--start-group 和 -Wl,--end-group 选项。这两个选项会告诉链接器在指定的库组中多次查找符号，以解决循环依赖问题。示例如下：

```sh
gcc your_source_files.o -o your_program -Wl,--start-group -lA -lB -Wl,--end-group
```
在 CMake 中，可以这样使用：
```cmake
target_link_libraries(your_program "-Wl,--start-group" libA libB "-Wl,--end-group")
```

## 5.4. 检查和调试
在调整链接顺序后，重新编译和链接项目。如果仍然存在链接错误，可以使用 -Wl,--verbose 选项来查看链接器的详细输出，帮助你定位问题。例如：
```sh
gcc -Wl,--verbose your_source_files.o -o your_program -L/path/to/libs -lA -lB -lC
```
链接器的详细输出会显示它查找符号的过程，你可以从中找出符号未找到的原因。


# 6.add_compile_options( -fsanitize=address ) 相当于  TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )?
**豆包ai**：
add_compile_options( -fsanitize=address ) 和 TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address ) 有相似之处，但并不完全等同，下面从多个方面为你详细分析：
## 6.1功能概述
add_compile_options( -fsanitize=address )：add_compile_options 是 CMake 中的一个命令，用于向编译器添加编译选项。-fsanitize=address 是 GCC 和 Clang 等编译器支持的一个选项，它会启用地址消毒剂（Address Sanitizer，ASan），在编译源文件时，编译器会对代码进行修改，插入额外的代码来检测内存访问错误。

TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )：TARGET_LINK_LIBRARIES 是 CMake 中用于指定目标链接哪些库的命令。这里将 -fsanitize=address 作为链接选项，在链接阶段告诉链接器需要链接地址消毒剂的运行时库。

## 6.2两者的区别
### 6.2.1. 作用阶段不同
add_compile_options( -fsanitize=address )：作**用于编译阶段**，当编译器处理每个源文件时，会根据该选项对代码进行修改，插入用于检测内存错误的代码。例如，在编译 .cpp 或 .c 文件时就会生效。

TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )：作**用于链接阶段**，链接器在将各个编译后的目标文件合并成可执行文件或共享库时，会根据该选项链接地址消毒剂的运行时库。

### 6.2.2. 影响范围不同
add_compile_options( -fsanitize=address )：该命令会影响所有后续使用该 CMakeLists.txt 文件进行编译的目标。也就是说，它会对所有源文件的编译过程都添加 -fsanitize=address 选项。

TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )：只对指定的目标（${TARGET}）生效，不会影响其他目标的链接过程。
### 6.2.3. 可能的效果差异
通常情况下，同时使用这两个选项可以正确启用地址消毒剂。但如果只使用 add_compile_options( -fsanitize=address ) 而不进行链接，可能会导致链接错误，因为虽然编译时插入了检测代码，但缺少相应的运行时库。
反之，如果只使用 TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address ) 而不在编译时添加该选项，那么编译后的代码中没有插入检测内存错误的代码，地址消毒剂也无法正常工作。

## 6.3建议

为了正确启用地址消毒剂，建议同时使用这两个选项：
```cmake
add_compile_options( -fsanitize=address )
TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )
```

这样可以确保在编译阶段插入检测代码，在链接阶段链接到所需的运行时库。同时，为了避免对所有目标产生不必要的影响，也可以使用 target_compile_options 来针对特定目标添加编译选项：

```cmake
target_compile_options(${TARGET} PRIVATE -fsanitize=address)
TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address )
```

综上所述，add_compile_options( -fsanitize=address ) 和 TARGET_LINK_LIBRARIES(${TARGET} PRIVATE -fsanitize=address ) 是相辅相成的，共同作用才能使地址消毒剂正常工作。
