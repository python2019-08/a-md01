#  【C_C++ 库的动态链接】深入理解动态链接器：RPATH, RUNPATH与$ORIGIN
泡沫o0  TCL实业控股股份有限公司 员工
发布于 2023-10-14 13:31・IP 属地上海
https://zhuanlan.zhihu.com/p/661280913
​
目录
> 1. 引言
> 1.1 动态链接的基本概念
> 1.2 动态链接器的角色
> 1.2.1 动态链接的优势
> 2. 动态链接的工作原理
> 2.1 动态链接的流程
> 2.2 符号解析的深入探讨
> 2.2.1 符号的种类
> 2.2.2 符号表
> 3. 动态链接与静态链接的对比
> 3.1 链接的基本概念
> 3.2 动态链接与静态链接的定义
> 3.3 动态链接与静态链接的优缺点
> 3.3.1 动态链接的优缺点
> 3.3.2 静态链接的优缺点
> 4. RPATH, RUNPATH与$ORIGIN的深入探讨
> 4.1 RPATH与RUNPATH的区别
> 4.1.1 RPATH的定义与用途
> 4.1.2 RUNPATH的定义与用途
> 4.2 $ORIGIN及其相关标记的应用
> 4.2.1 $ORIGIN的深入探讨
> 4.2.2 使用$ORIGIN的示例
> 4.3 $LIB与多架构系统的关系
> 4.3.1 $LIB标记的定义
> 4.3.2 $LIB的应用示例
> 4.3.3 $LIB与多架构系统的优势
> 4.4 $PLATFORM的概念与应用
> 4.4.1 $PLATFORM的定义
> 4.4.2 $PLATFORM的应用示例
> 4.4.3 $PLATFORM的局限性
> 5. 在CMake和GCC中设置RPATH
> 5.1 使用CMake设置RPATH的方法
> 5.2 使用GCC的-rpath选项进行设置
> 5.3 动态链接器的搜索路径
> 5.3.1 LD_LIBRARY_PATH环境变量的作用
> 5.3.2 默认的库路径及其重要性
> 5.3.3 使用ldconfig更新链接器缓存的方法
> 6. 实际应用：解决常见的动态链接问题
> 6.1 使用ldd工具进行问题诊断
> 6.1.1 ldd的输出解析
> 6.2 使用readelf检查RPATH和RUNPATH设置
> 6.3 常见的动态链接问题及其解决方案
> 6.3.1 缺少库文件
> 6.3.2 库版本不匹配
> 结语


# 1. 引言
## 1.1 动态链接的基本概念
在C/C++编程中，链接是一个至关重要的过程，它将多个对象文件或库文件组合成一个可执行文件。链接可以分为两种：静态链接和动态链接。

* **静态链接 (Static Linking)**：在这种方式下，所有的库函数都会被复制到最终的可执行文件中。这意味着，如果有多个程序使用同一个库，那么这个库的代码会在每个程序中都有一个副本。
* **动态链接 (Dynamic Linking)**：与静态链接相反，动态链接不会将库的代码复制到可执行文件中。相反，它只是在运行时加载所需的库。这样，多个程序可以共享同一个库的单一副本。
  
从心理学的角度来看，人们喜欢将事物分类和组织，这有助于我们更好地理解和记忆信息。同样，动态链接也是一种组织代码的方式，它允许我们将代码模块化，使得多个程序可以共享同一个代码库，从而节省空间和提高效率。

> "我们是按照我们所知道的方式来看待世界的。" - Immanuel Kant
这句话在编程中同样适用。我们的代码结构和组织方式反映了我们如何看待问题和解决方案。

## 1.2 动态链接器的角色
**动态链接器 (Dynamic Linker)** 是操作系统的一部分，负责在**程序运行时**加载和链接所需的**共享库**。例如，在Linux系统中，ld.so或ld-linux.so就是动态链接器。

当你运行一个程序时，动态链接器首先检查这个程序需要哪些共享库，并查找这些库的位置。一旦找到，它就会加载这些库到内存中，并解析程序中的符号引用，确保它们指向正确的地址。

从心理学的角度来看，动态链接器就像是我们大脑中的"工作记忆"，它负责处理和组织当前任务所需的信息。正如工作记忆确保我们可以快速访问和处理信息，动态链接器也确保程序可以快速访问其依赖的库。

> "工作记忆是思考的空间。" - Steven Pinker
这与动态链接的工作方式非常相似。动态链接器为程序提供了一个"思考空间"，在这个空间中，程序可以访问和使用其依赖的库。

#1.2.1 动态链接的优势

优势     | 描述
--------|----------------------------------------------------------
节省空间 | 多个程序可以共享同一个库的副本，而不是每个程序都有自己的副本。
易于更新 | 更新一个库不需要重新链接所有使用该库的程序。
模块化   | 允许程序员将代码组织成可重用的模块。

从心理学的角度来看，人们喜欢简洁和效率。动态链接正好满足了这两个需求，它使得代码更加模块化，更容易维护和更新。

# 2. 动态链接的工作原理
## 2.1 动态链接的流程
动态链接的过程可以看作是一个解决问题的心理过程。当我们面临一个问题时，我们的大脑会自动寻找已知的解决方案或策略。同样，当程序运行时，动态链接器会自动寻找程序所需的库，并确保它们正确地链接在一起。

1. **加载程序**：当你运行一个程序时，操作系统首先加载程序的可执行文件到内存中。
2. **解析依赖**：动态链接器检查程序的头部，找出程序依赖的所有共享库。
3. **加载共享库**：动态链接器查找这些共享库的位置，并将它们加载到内存中。
4. **符号解析**：动态链接器解析程序中的符号引用，确保它们指向正确的地址。

> "问题解决是大脑的核心功能。" - Daniel Levitin
这与动态链接的工作方式非常相似。动态链接器解决了程序如何访问和使用其依赖库的问题。

## 2.2 符号解析的深入探讨
符号解析是动态链接过程中的关键步骤。它确保程序中的每个符号引用都指向正确的地址。

### 2.2.1 符号的种类
在C/C++中，符号可以是变量、函数或其他实体。这些符号在链接时需要被解析，以确保它们指向正确的地址。

符号类型 | 描述 | 示例
--------|----|---
变量 | 存储数据的位置 | int x;
函数 | 执行特定任务的代码块 | void foo() {...}
类型 | 定义数据结构的模板 | struct Point {...};

从心理学的角度来看，符号就像是我们大脑中的概念或想法。我们使用这些概念来理解和解释世界。同样，程序使用符号来引用和组织代码。

### 2.2.2 符号表
符号表是一个数据结构，它存储了程序中所有的符号及其地址。动态链接器使用符号表来解析符号引用。

当我们学习新的概念或信息时，我们的大脑会将它们存储在记忆中。同样，符号表存储了程序中的所有符号，以便在链接时使用。

> "记忆是知识的仓库。" - Aristotle
这与符号表的作用非常相似。符号表是程序知识的仓库，它存储了程序中所有的符号及其地址。

# 3. 动态链接与静态链接的对比
## 3.1 链接的基本概念
在深入探讨动态链接与静态链接的区别之前，我们首先需要理解链接的基本概念。链接是将多个对象文件和库组合成一个可执行文件的过程。这就像我们的大脑将多个记忆片段组合成一个完整的故事。

> "我们的记忆是我们的连续性，我们的理智，我们的感觉，我们的行动，没有它，我们就是什么都不是。" - Luis Buñuel

## 3.2 动态链接与静态链接的定义
* **动态链接**：在程序运行时，需要的库被加载到内存中。这意味着多个程序可以共享同一个库的单一副本。
* **静态链接**：在编译时，所有需要的库都被复制到最终的可执行文件中。这导致可执行文件较大，但它是自包含的。

从心理学的角度看，动态链接就像是我们的短期记忆，它是临时的、灵活的，可以根据需要加载或卸载。而静态链接则像是我们的长期记忆，一旦形成，就永久保存。

## 3.3 动态链接与静态链接的优缺点
### 3.3.1 动态链接的优缺点
优点     | 缺点
--------|---
节省内存，因为多个程序可以共享同一个库的副本 | 需要确保运行环境中有所需的库
程序更新时，只需更新库文件，而不是每个使用该库的程序 | 可能会出现版本冲突，导致程序崩溃
可执行文件较小 | 加载程序时可能会稍微慢一些，因为需要加载库

### 3.3.2 静态链接的优缺点
优点  | 缺点
-----|---
可执行文件是自包含的，不依赖于外部库 | 可执行文件较大
运行速度可能稍微快一些，因为所有代码都在一个文件中 | 更新库时，需要重新编译和链接所有使用该库的程序
不会出现版本冲突 | 内存使用率较高，因为每个程序都有其自己的库副本

从心理学的角度看，选择动态链接还是静态链接就像是权衡短期和长期的回报。动态链接提供了更大的灵活性，但可能需要更多的维护。而静态链接则提供了稳定性，但牺牲了一些灵活性。

> "选择不仅仅是选择，它是放弃。为了得到你想要的，你必须放弃你不想要的。" - Roy T. Bennett

# 4. RPATH, RUNPATH与$ORIGIN的深入探讨
在嵌入式领域，我们经常会遇到各种链接问题，尤其是在动态链接的环境中。为了更好地理解这些问题，我们需要深入探讨RPATH, RUNPATH和$ORIGIN这些关键概念。 
从心理学的角度来看，人们往往对于复杂的技术问题感到困惑，因为他们缺乏对这些问题背后的基本原理的了解。正如心理学家Carl Rogers所说：“我们所知道的只是我们所知道的。”（我们只知道我们所知道的那部分）。因此，我们需要从底层开始，逐步揭示这些概念背后的原理。

## 4.1 RPATH与RUNPATH的区别
在C++的世界中，RPATH和RUNPATH是两个经常被提及的概念，但它们之间的区别是什么呢？

### 4.1.1 RPATH的定义与用途
RPATH（Runtime Library Path，运行时库路径）是一个在可执行文件或共享库中嵌入的路径，它指定了动态链接器在运行时应该搜索的目录。这是一个非常有用的功能，尤其是当我们的程序依赖于某些非标准位置的库时。

例如，考虑以下情况：你有一个程序myprog，它依赖于libfoo.so这个库。这个库位于/opt/mylibs/目录下，而这个目录并不在系统的默认库搜索路径中。通过在myprog中设置RPATH为/opt/mylibs/，你可以确保myprog在运行时能够找到libfoo.so。

```cpp
// myprog.cpp
#include <foo.h>

int main() {
    foo_function();
    return 0;
}
```
在编译时，你可以使用以下命令来设置RPATH：

```
g++ myprog.cpp -L/opt/mylibs/ -lfoo -Wl,-rpath,/opt/mylibs/
```
### 4.1.2 RUNPATH的定义与用途
与RPATH类似，RUNPATH（运行路径）也是一个在可执行文件或共享库中嵌入的路径。但与RPATH不同的是，当设置了RUNPATH时，动态链接器会忽略LD_LIBRARY_PATH环境变量。这意味着，如果你的程序设置了RUNPATH，那么即使你在环境变量中指定了正确的库路径，动态链接器也不会使用它。

这种行为可能会导致一些混淆，但它实际上是为了增加安全性。考虑这样一个场景：攻击者可以控制LD_LIBRARY_PATH，并使其指向一个包含恶意版本的libfoo.so的目录。如果你的程序使用RPATH，那么攻击者可以通过修改LD_LIBRARY_PATH来劫持你的程序。但如果你使用RUNPATH，这种攻击就不再有效。

方法     | 优点 | 缺点
--------|------|---
RPATH   | 可以与LD_LIBRARY_PATH一起使用 | 可能受到LD_LIBRARY_PATH劫持的攻击
RUNPATH | 更加安全，不受LD_LIBRARY_PATH劫持的攻击 | 忽略LD_LIBRARY_PATH，可能导致正确的库不被加载

从心理学的角度来看，人们往往会选择最简单和直观的方法来解决问题，而不是最安全的方法。这就是为什么RPATH在过去更为流行，而RUNPATH则是一个相对较新的概念。但随着安全意识的增强，RUNPATH的使用也越来越普及。

## 4.2 $ORIGIN及其相关标记的应用
$ORIGIN是一个特殊的标记，它 **在动态链接时表示可执行文件或共享库的当前路径** 。这是一个非常有用的功能，尤其是当我们需要创建一个可移植的应用程序或库时。

假设我们有一个应用程序myapp，它依赖于libbar.so这个库。我们希望将这两个文件打包到一个目录中，并确保无论这个目录被复制到哪里，myapp都能正确地找到libbar.so。

为了实现这一点，我们可以在编译myapp时设置RPATH为$ORIGIN：

g++ myapp.cpp -L. -lbar -Wl,-rpath,'$ORIGIN'
这样，无论myapp和libbar.so被复制到哪里，myapp都会在其当前目录中搜索libbar.so。

### 4.2.1 $ORIGIN的深入探讨
当我们谈论$ORIGIN时，我们实际上是在讨论一个动态链接器在解析共享库时使用的变量。这意味着，当程序启动时，动态链接器会将$ORIGIN替换为程序的实际路径。

这种机制的美妙之处在于它的灵活性。考虑这样一个场景：你有一个应用程序和多个共享库，它们都位于同一个目录中。通过使用$ORIGIN，你可以确保无论这个目录被移动到哪里，应用程序都能正确地找到它的依赖库。

### 4.2.2 使用$ORIGIN的示例
假设我们有以下目录结构：
```
/myapp/
|-- myapp_executable
|-- lib/
    |-- libfoo.so
    |-- libbar.so
```

我们希望无论/myapp/目录被移动到哪里，myapp_executable都能正确地找到libfoo.so和libbar.so。

为了实现这一点，我们可以在编译myapp_executable时设置RPATH为$ORIGIN/lib：
```sh
g++ myapp_executable.cpp -L./lib -lfoo -lbar -Wl,-rpath,'$ORIGIN/lib'
```
这样，无论/myapp/目录被复制到哪里，myapp_executable都会在其当前目录的lib子目录中搜索libfoo.so和libbar.so。

从心理学的角度来看，这种方法满足了人们对简单性和直观性的需求。正如C++之父Bjarne Stroustrup所说：“C++的设计目标是使简单事情变得简单，复杂事情变得可能。”（C++的目的是让简单的事情保持简单，而让复杂的事情成为可能）。$ORIGIN正是这种设计哲学的体现，它为我们提供了一种简单而直观的方法来解决动态链接的问题。

## 4.3 $LIB与多架构系统的关系
在深入探讨$LIB及其在多架构系统中的应用之前，我们首先需要理解多架构系统的基本概念。多架构系统是指一个系统支持多种不同的硬件架构，例如x86、ARM、MIPS等。这种设计允许开发者为特定的硬件架构编写和优化代码，同时确保代码在其他架构上也能正常运行。

### 4.3.1 $LIB标记的定义
$LIB是动态链接器使用的一个特殊标记，它用于指定共享库的搜索路径。在多架构系统中，$LIB可以被替换为特定架构的目录，例如lib32（32位系统）或lib64（64位系统）。

这意味着，当一个应用程序在64位系统上运行时，动态链接器会自动搜索lib64目录下的共享库，而在32位系统上则会搜索lib32目录。

### 4.3.2 $LIB的应用示例
考虑以下目录结构：
```
/myapp/
|-- myapp_executable
|-- lib32/
    |-- libfoo.so
|-- lib64/
    |-- libfoo.so
```
为了确保myapp_executable在不同的架构上都能找到正确的libfoo.so，我们可以在编译时设置RPATH为$ORIGIN/$LIB：
```sh
g++ myapp_executable.cpp -L./$LIB -lfoo -Wl,-rpath,'$ORIGIN/$LIB'
```
这样，myapp_executable会根据其运行的系统架构自动选择lib32或lib64目录。

从心理学的角度来看，这种设计满足了人们对一致性和预测性的需求。正如心理学家Daniel Kahneman在其著作《思考，快与慢》中所说：“人们对一致性和稳定性有着深深的渴望。”（People have a deep desire for consistency and stability.）$LIB为开发者提供了一种简单而一致的方法来处理多架构系统中的动态链接问题。

### 4.3.3 $LIB与多架构系统的优势
1. **灵活性**：$LIB提供了一种灵活的方式来处理不同架构的共享库，无需为每种架构编写特定的代码。
2. **简洁性**：使用$LIB可以减少代码的复杂性，使得代码更加简洁和易于维护。
3. **一致性**：$LIB确保了在不同的架构上都能得到相同的行为，提高了代码的可预测性。

## 4.4 $PLATFORM的概念与应用
$PLATFORM是动态链接器中的另一个特殊标记，它主要与多架构支持有关。在深入探讨$PLATFORM的应用之前，我们首先需要理解其背后的概念。

### 4.4.1 $PLATFORM的定义
$PLATFORM是一个由动态链接器解析的特殊变量，它表示正在运行的系统的硬件平台。这个标记的主要目的是允许开发者为不同的硬件平台提供特定的共享库版本，而不需要更改应用程序的代码或设置。

例如，一个应用程序可能需要在x86和ARM两种架构上运行。通过使用$PLATFORM，开发者可以为每种架构提供一个特定的共享库版本，而应用程序可以在启动时动态地选择正确的版本。

### 4.4.2 $PLATFORM的应用示例
假设我们有以下目录结构：
```
/myapp/
|-- myapp_executable
|-- lib/
    |-- x86/
        |-- libfoo.so
    |-- arm/
        |-- libfoo.so
```
我们希望myapp_executable能够根据其正在运行的硬件平台自动选择正确的libfoo.so版本。

为了实现这一点，我们可以在编译myapp_executable时设置RPATH为$ORIGIN/lib/$PLATFORM：
```sh
g++ myapp_executable.cpp -L./lib/$PLATFORM -lfoo -Wl,-rpath,'$ORIGIN/lib/$PLATFORM'
```
这样，当myapp_executable在x86架构上运行时，它会加载lib/x86/libfoo.so，而在ARM架构上运行时，它会加载lib/arm/libfoo.so。

从心理学的角度来看，这种方法为开发者提供了一种简单而直观的方式来处理多架构支持的复杂性。正如心理学家Abraham Maslow所说：“如果你只有一个锤子，你会看到每一个问题都像一个钉子。”（如果你只有一个工具，你会把每个问题都当作那个工具可以解决的问题）。$PLATFORM为我们提供了一个强大的工具，使我们能够更灵活地处理多架构的问题，而不是被限制在一个特定的解决方案中。

### 4.4.3 $PLATFORM的局限性
尽管$PLATFORM为多架构支持提供了一个强大的解决方案，但它也有其局限性。首先，它依赖于动态链接器正确地解析$PLATFORM变量。此外，如果应用程序需要支持的硬件平台超出了动态链接器的知识范围，那么$PLATFORM可能不会正常工作。

总之，$PLATFORM是一个强大的工具，但在使用它时，开发者需要注意其潜在的局限性，并确保他们的应用程序在所有目标平台上都能正常工作。

# 5. 在CMake和GCC中设置RPATH
在编程的世界中，我们经常遇到各种各样的问题，而这其中，动态链接库的问题尤为常见。为了更好地理解这些问题，我们需要深入了解RPATH的设置方式。这不仅仅是一个技术问题，更多的是一个心理问题。当我们理解了为什么要这样设置，背后的原因，我们就能更好地应对各种问题。

## 5.1 使用CMake设置RPATH的方法
CMake是一个非常强大的构建工具，它可以帮助我们更容易地管理和构建项目。在CMake中，我们可以使用set_target_properties来设置RPATH。
```cmake
set_target_properties(target PROPERTIES
    BUILD_WITH_INSTALL_RPATH TRUE
    INSTALL_RPATH "/path/to/lib")
```    
这里的target是你的目标名称，/path/to/lib是你希望设置的RPATH路径。

为什么我们要这样设置呢？从心理学的角度来看，人们总是希望事情能够简单、直接。当我们设置了RPATH，我们就告诉了系统，当它需要查找动态链接库时，应该首先查找这个路径。这样，系统就不需要在其他地方浪费时间去查找了。

## 5.2 使用GCC的-rpath选项进行设置
GCC是一个非常古老且强大的编译器。在GCC中，我们可以使用-rpath选项来设置RPATH。
```sh
gcc -o output input.c -Wl,-rpath,/path/to/lib
```
这里，-Wl告诉GCC将后面的选项传递给链接器，-rpath则是设置RPATH的选项。

从心理学的角度来看，这种方法更加直观。我们直接告诉编译器我们的意图，而不需要通过其他工具。这也是为什么很多老的C/C++程序员更喜欢使用这种方法的原因。
## 5.2+附：豆包ai详解 g++ 的 -rpath选项
在使用 g++ 编译和链接程序时，-rpath 是一个非常重要的选项，它主要用于指定运行时动态库的搜索路径。 
-rpath 选项允许你在链接时将指定的路径嵌入到可执行文件或共享库中，这样在程序运行时，系统会优先从这些路径中搜索所需的动态库。
### 5.2+.1 基本语法
```bash
g++ -o output_file input_files -L/path/to/library -l library_name -Wl,-rpath,/path/to/runtime/library
```
解释：
-L/path/to/library：指定链接时搜索库文件的路径。
-l library_name：指定要链接的库名。
-Wl,-rpath,/path/to/runtime/library：-Wl 是 g++ 的选项，用于将后面的参数传递给链接器（如 ld），-rpath 是链接器的选项，/path/to/runtime/library 是你要指定的运行时动态库搜索路径。可以指定多个路径，用冒号 : 分隔。
### 5.2+.2使用示例
假设你有一个简单的 C++ 程序 main.cpp，它使用了一个自定义的动态库 libmylib.so，该动态库位于 /home/user/mylib 目录下。
#### (1). 编写程序和动态库代码
main.cpp：
```cpp
#include <iostream>
#include "mylib.h"

int main() {
    myFunction();
    return 0;
}
```

mylib.h：
```cpp
#ifndef MYLIB_H
#define MYLIB_H

void myFunction();

#endif
```

mylib.cpp：
```cpp
#include <iostream>
#include "mylib.h"

void myFunction() {
    std::cout << "This is my custom library function." << std::endl;
}
```

#### (2). 编译动态库
```bash
g++ -shared -fPIC mylib.cpp -o libmylib.so
mv libmylib.so /home/user/mylib
```
#### (3) 编译主程序并指定 -rpath
```bash
g++ -o main main.cpp -L/home/user/mylib -lmylib -Wl,-rpath,/home/user/mylib
```
#### （4）. 运行程序
```bash
./main
```
由于使用了 -rpath 选项，程序在运行时会去 /home/user/mylib 目录中搜索 libmylib.so 动态库。
### 5.2+.3注意事项
* **安全性问题**：-rpath 会将路径硬编码到可执行文件中，如果该路径中的库文件被恶意替换，可能会导致安全风险。
* **多路径指定**：可以指定多个路径，例如 -Wl,-rpath,/path1:/path2:/path3，系统会按照指定的顺序依次搜索这些路径。
* **相对路径**：-rpath 也可以使用相对路径，例如 -Wl,-rpath,$ORIGIN/../lib，$ORIGIN 表示可执行文件所在的目录。



## 5.3 动态链接器的搜索路径
当我们运行一个程序时，动态链接器需要知道去哪里查找需要的动态链接库。这就涉及到了动态链接器的搜索路径。

### 5.3.1 LD_LIBRARY_PATH环境变量的作用
LD_LIBRARY_PATH是一个环境变量，它告诉动态链接器在哪里查找动态链接库。例如：
```sh
export LD_LIBRARY_PATH=/path/to/lib:$LD_LIBRARY_PATH
```
这样，当我们运行一个程序时，动态链接器就会首先在/path/to/lib这个路径下查找需要的动态链接库。

从心理学的角度来看，这是一种"最后的手段"。当其他方法都失败时，我们可以使用这种方法来解决问题。但是，这也是一把双刃剑。因为它会影响到所有的程序，所以我们需要谨慎使用。

### 5.3.2 默认的库路径及其重要性
动态链接器有一些默认的搜索路径，例如/lib、/usr/lib等。这些路径在系统上通常都有一些常用的动态链接库。

从心理学的角度来看，这是一种"安全网"。当我们的程序没有明确指定RPATH，或者LD_LIBRARY_PATH没有设置时，动态链接器就会使用这些默认的路径。这样，我们就不需要担心因为忘记设置某个路径而导致的问题。

### 5.3.3 使用ldconfig更新链接器缓存的方法
当我们安装了一个新的动态链接库，或者更改了某个动态链接库的路径时，我们需要告诉动态链接器这个变化。这时，我们就可以使用ldconfig命令来更新链接器的缓存。

从心理学的角度来看，这是一种"刷新记忆"的方法。当我们的记忆与现实不符时，我们需要更新我们的记忆。同样，当链接器的缓存与实际的文件不符时，我们就需要使用ldconfig来更新它。

# 6. 实际应用：解决常见的动态链接问题
在我们的编程生涯中，经常会遇到各种各样的问题，而动态链接问题无疑是其中的一大难题。为什么有些程序在一个环境中可以正常运行，而在另一个环境中却会出现链接错误呢？为什么有时候我们的程序会因为某个库的缺失而崩溃？这些问题背后，往往隐藏着人性的弱点和习惯。正如心理学家弗洛伊德（Sigmund Freud）所说：“人的行为和决策往往受到潜意识的驱使。”在编程中，我们的决策和行为也受到我们的经验、知识和习惯的影响。

## 6.1 使用ldd工具进行问题诊断
当我们遇到一个动态链接问题时，第一反应往往是使用ldd工具来诊断。ldd（List Dynamic Dependencies）是一个列出程序动态依赖的工具。

例如，当我们有一个名为my_program的程序，我们可以使用以下命令来查看它的动态链接依赖：
```sh
$ ldd my_program
```
这将列出my_program依赖的所有动态库。但是，为什么我们会这么做呢？这背后的原因与人类的好奇心有关。我们总是想知道事情的原因，这是我们的本能。正如心理学家卡尔·荣格（Carl Jung）所说：“人类的好奇心是他们进步的动力。”

### 6.1.1 ldd的输出解析
当你运行ldd命令时，你可能会看到如下的输出：

linux-vdso.so.1 =>  (0x00007ffcc35fc000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4e4d9a1000)
/lib64/ld-linux-x86-64.so.2 (0x00007f4e4dd8c000)
这里，linux-vdso.so.1、libc.so.6和/lib64/ld-linux-x86-64.so.2都是my_program的动态链接依赖。但是，你可能会注意到linux-vdso.so.1后面有一个箭头，但是没有路径。这是因为linux-vdso.so.1是一个虚拟的动态共享对象，它不在文件系统中，而是由内核提供的。

这种深入的分析可以帮助我们更好地理解问题，并找到解决方案。正如C++之父Bjarne Stroustrup在其著作《C++编程语言》中所说：“深入理解问题是找到解决方案的关键。”

## 6.2 使用readelf检查RPATH和RUNPATH设置
readelf是另一个非常有用的工具，它可以显示ELF（Executable and Linkable Format）文件的信息。ELF是Linux和许多其他UNIX-like系统上的标准二进制格式。

当我们想知道一个程序的RPATH（Runtime Library Search Path）或RUNPATH设置时，我们可以使用readelf。

例如，要查看my_program的RPATH和RUNPATH设置，我们可以使用以下命令：
```sh
$ readelf -d my_program | grep -E 'RPATH|RUNPATH'
```
这将显示my_program的RPATH和RUNPATH设置。这些设置告诉动态链接器在哪里查找动态库。

但为什么我们需要知道这些设置呢？这与我们的需求和习惯有关。我们习惯于将库放在特定的位置，例如/usr/local/lib或/opt/mylibs。但是，动态链接器可能不知道这些位置。这时，RPATH和RUNPATH就派上了用场。

正如心理学家阿布拉罕·马斯洛（Abraham Maslow）在其著名的需求层次理论中所说：“人们总是努力满足他们的基本需求。”在编程中，我们的基本需求之一就是确保我们的程序可以找到它所需的所有库。

方法 | 优点 | 缺点
-----|----|---
RPATH   | 可以设置多个路径   | 不能被环境变量覆盖
RUNPATH | 可以被环境变量覆盖 | 只能设置一个路径

这个表格简单地总结了RPATH和RUNPATH的优缺点。通过这种方式，我们可以更容易地比较和选择最适合我们需求的方法。

## 6.3 常见的动态链接问题及其解决方案
在实际应用中，我们经常遇到各种动态链接问题。这些问题可能是由于各种原因引起的，例如库的版本不匹配、库的路径不正确或库文件损坏。

### 6.3.1 缺少库文件
这是最常见的问题之一。当你尝试运行一个程序时，你可能会看到如下的错误消息：

> error while loading shared libraries: libexample.so.1: cannot open shared object file: No such file or directory

这意味着动态链接器无法找到libexample.so.1这个库。为了解决这个问题，我们需要确保这个库在动态链接器的搜索路径中。

解决方法：
> 1. 使用ldconfig命令更新链接器的缓存。
> 2. 将库的路径添加到LD_LIBRARY_PATH环境变量中。
> 3. 使用rpath或runpath设置程序的库搜索路径。
   
### 6.3.2 库版本不匹配
当你尝试运行一个程序时，你可能会看到如下的错误消息：

> error while loading shared libraries: libexample.so.1: version `V2.0' not found (required by my_program)
这意味着my_program需要libexample.so.1的V2.0版本，但是系统上安装的是另一个版本。

解决方法：
> 1. 安装正确的库版本。
> 2. 使用静态链接，这样程序就不依赖于外部的库版本。

# 7.结语
在我们的编程学习之旅中，理解是我们迈向更高层次的重要一步。然而，掌握新技能、新理念，始终需要时间和坚持。从心理学的角度看，学习往往伴随着不断的试错和调整，这就像是我们的大脑在逐渐优化其解决问题的“算法”。

这就是为什么当我们遇到错误，我们应该将其视为学习和进步的机会，而不仅仅是困扰。通过理解和解决这些问题，我们不仅可以修复当前的代码，更可以提升我们的编程能力，防止在未来的项目中犯相同的错误。

我鼓励大家积极参与进来，不断提升自己的编程技术。无论你是初学者还是有经验的开发者，我希望我的博客能对你的学习之路有所帮助。如果你觉得这篇文章有用，不妨点击收藏，或者留下你的评论分享你的见解和经验，也欢迎你对我博客的内容提出建议和问题。每一次的点赞、评论、分享和关注都是对我的最大支持，也是对我持续分享和创作的动力。

  
------------------------------------------------------- 
​5 条评论  
默认
最新
神不语
神不语
关于LD_LIBRARY_PATH、rpath、runpath的优先级错了，应该是rpath > LD_LIBRARY_PATH > runpath

2023-12-18 · 四川
​回复
​2
大石头
大石头
runpath<LD_LIBRARY_PATH?

2024-01-11 · 浙江
​回复
​喜欢
雪碧加冰
雪碧加冰
RPATH > LD_LIBRARY_PATH > RUNPATH吧

2024-04-19 · 广东
​回复
​1
金士桥阿昵
金士桥阿昵
心理学的引用很赞👍
2023-10-23 · 上海
​回复
​1
张胖孩
张胖孩
应该是runpath更容易受到劫持吧

2024-08-12 · 中国香港
----------------------------------------------------------------------------
----------------------------------------------------------------------------
# 8.LD_LIBRARY_PATH、rpath、runpath的优先级
在 Linux 系统中，LD_LIBRARY_PATH、rpath 和 runpath 都与动态库的搜索路径有关，但它们的优先级和使用场景有所不同。下面详细介绍它们的优先级关系。

## 8.1 三者的基本概念
* LD_LIBRARY_PATH：这是一个环境变量，用户可以通过设置该变量来指定额外的动态库搜索路径。当程序运行时，系统会先从 LD_LIBRARY_PATH 所指定的路径中搜索所需的动态库。例如，通过以下命令可以临时设置该环境变量：
```bash
export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH
```

* rpath：rpath 是在链接可执行文件或共享库时，通过 -Wl,-rpath 选项指定的动态库搜索路径。这些路径会被嵌入到可执行文件或共享库中，在程序运行时，系统会根据这些路径搜索动态库。例如：
```bash
g++ -o my_program main.cpp -L/path/to/library -lmylib -Wl,-rpath,/path/to/library
```

* runpath：runpath 与 rpath 类似，也是在链接时指定的动态库搜索路径，通过 -Wl,-rpath-link 和 -Wl,--enable-new-dtags 结合使用来指定。例如：
```bash
g++ -o my_program main.cpp -L/path/to/library -lmylib -Wl,-rpath-link,/path/to/library -Wl,--enable-new-dtags
```

## 8.2优先级顺序
三者的优先级顺序如下（从高到低）：
(1) LD_LIBRARY_PATH：如果设置了 LD_LIBRARY_PATH 环境变量，系统会首先从该环境变量指定的路径中搜索动态库。这意味着即使可执行文件中已经设置了 rpath 或 runpath，LD_LIBRARY_PATH 中的路径仍然会被优先搜索。例如：
```bash
export LD_LIBRARY_PATH=/custom/path:$LD_LIBRARY_PATH
./my_program
```
在这种情况下，系统会先在 /custom/path 中搜索所需的动态库。

(2)rpath（在不使用 --enable-new-dtags 时）：如果没有设置 LD_LIBRARY_PATH，并且在链接时使用了 -Wl,-rpath 选项（未使用 --enable-new-dtags），系统会按照 rpath 中指定的路径搜索动态库。例如：
```bash
g++ -o my_program main.cpp -L/path/to/library -lmylib -Wl,-rpath,/path/to/library
./my_program
```
此时，系统会在 /path/to/library 中搜索动态库。

(3)runpath（使用 --enable-new-dtags 时）：如果在链接时使用了 -Wl,--enable-new-dtags 选项，那么 rpath 会被解释为 runpath。runpath 的优先级低于 rpath，并且在搜索 runpath 指定的路径之前，系统会先搜索系统默认的动态库搜索路径（如 /lib、/usr/lib 等）。例如：
```bash
g++ -o my_program main.cpp -L/path/to/library -lmylib -Wl,-rpath,/path/to/library -Wl,--enable-new-dtags
./my_program
```
系统会先搜索默认路径，然后再搜索 /path/to/library。

(4)系统默认路径：如果以上三者都没有指定相关路径，系统会从默认的动态库搜索路径中搜索所需的动态库，这些默认路径通常包括 /lib、/usr/lib 等。

## 8.4总结
* LD_LIBRARY_PATH 具有最高的优先级，它可以临时改变动态库的搜索路径。
* rpath 在不使用 --enable-new-dtags 时优先级较高，会直接嵌入到可执行文件中。
* runpath 在使用 --enable-new-dtags 时生效，优先级低于 rpath，且在搜索前会先搜索系统默认路径。