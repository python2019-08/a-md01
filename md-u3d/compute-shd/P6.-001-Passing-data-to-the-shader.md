# 0 contents
 
P6.-001-Passing-data-to-the-shader
P7.-002-The-joy-of-buffers
P8.-003-Orbiting-stars
P9.-004-Using-noise-in-the-shader
P10.-005-Mesh-deformation
P11.-006-Challenge-Draw-a-polygon

P12.-001-Setting-up-the-rendering
P13.-002-A-simple-blur-effect
P14.-003-Night-vision-lenses
P15.-004-A-HUD-overlay---part-1
P16.-005-A-HUD-overlay---part-2
P17.-006-A-star-glow-effect-vertex
P18.-007-A-star-glow-effect-vertex
P19.-008-Challenge-Create-a-sepia-

# P6.-001-Passing-data-to-the-shader
[00:00:00.000 --> 00:00:15.680]   First steps. Passing data to the shader.
[00:00:15.680 --> 00:00:22.000]   In the previous section we saw how easily you can pass data from the CPU side, a C#
[00:00:22.000 --> 00:00:29.160]   MonoBehaviour script, to the GPU side, a Compute shader. 
We've used the Compute shader method SetInt to set an integer value, SetVector to set a Float4 value, and SetTexture to set an RWTexture2D.

In this video we'll get some more practice passing data from the CPU to the GPU, and set the groundwork for the next video where we'll look at using buffers which allow us to pass huge chunks of data.

[00:00:56.120 --> 00:01:01.560]   Open the scene PassData in the StartProject. If you run the program you'll see an outline  red circle in the middle of the quad. 

If we look at the "PassData.Compute" shader you'll see a call to drawCircle in the circle's kernel. 
Notice that here we have a single thread in the X, Y and Z dimensions. 

Look at the "PassData.cs" script that is a component added to the quad, and look at the DispatchKernel() method and notice it uses the past parameter count as  the value used for the X thread group size, with Y and Z set to 1. 

Little challenge for you. If you dispatch uses 1 for the X, Y and Z thread group sizes and the shader uses 1 for X, Y and Z, how many times does the shader kernel run when dispatch is called? Pause now and think about it. 

What value did you come up with? It's simply 1 x 1 x 1 = 1 for the dispatch group, and 1 x 1 x 1 = 1 for the threads, giving 1 x 1 = 1. It will run  just once. 

If you're coming from knowledge of fragment shaders you may be baffled  as to how a single call of the GPU shader can result in a circle getting drawn. The answer  is the shader has complete control over what it does to the result texture. Here we use a single thread of the shader to draw a complete circle, not an individual pixel. 

Don't get too concerned about the drawCircle() function. It uses classic computer graphics methods for rasterising a circle. To summarise the method we know that a circle has an infinite  number of lines of symmetry. 
For our purposes we assume that we can divide it into 8 sections  and only concentrate on calculations for one section. The others are simply mirrored around by negating the X or Y value or switching their values. 
Starting at 0 radius and incrementing X by 1 for each pass of a loop we use a clever method, actually a special case of Bressenham's line algorithm, named after Jack Elton Bressenham, to decide if we should or should not decrement Y. 

Then we set the pixel for X Y, and in addition X minus Y minus X Y minus X minus Y Y X Y minus X minus Y X minus Y minus X. So we set 8 pixels for each pass of the loop. 
If you're interested in a more complete understanding then take a look at this address. 

For our current purposes I want to stress the difference between a fragment shader which can set the  colour for a single pixel and a compute shader which can do more or less anything a small computer program can do. 

Before we go on to start passing more data from the CPU to the GPU, the first thing we'll do is let the user control the clear colour and the certain outline colour.   
Notice that the clear colour and the certain colour are public properties of the passdata.cs script.   

In the compute shader let's add some variables that we can use to track these values.  A colour as we know is a floatFor value. In the shader add float For clearColor , float For circleColor. 

Then switching back to the C# script add shader.setVector clearColor clearColor, shader.setVector circleColor circleColor to the initShader method. 
Notice we pass a colour property using the setVector method. setVector assumes a property that includes  four float values and a colour is just that. The data in a colour is a float value for red, green, blue and alpha. Now we've passed the values but we need to use them in the  shader. 

[00:05:12.040 --> 00:05:19.480]  The circle colour is easy. We just need to switch the value floatFor 1001 in the plot1 function to circleColor. 
This method is where the pixelColor value is set but we  will need a clear method that will fill every pixel in the texture with the clear colour  before we draw the circles. Let's add a second kernel. In the shader copy the circle's pragma  and paste it in renaming it clear. Then copy the circle's function and paste it in below.

Change the name to clear and switch the numThreads line to 881 and change the content of the function to what. 
Pause the video and think about it. 
The answer is simple. resultId.xy  equals clearColor. 

Because both kernels are right into the same texture it's a good idea  to add a compiler guide "shared". 

In the C# script we need to add a new handle, add intClearHandle and use findKernel to initialise this value. Assignment of textures are per kernel handle  so you need to call setTexture using the clearHandle result and outputTexture. It just remains  to dispatch the clear kernel in the dispatchKernel method which we should change to dispatchKernels. 
What should we use as the group sizes? Pause the video and think about the answer. 
Because  we set the threads to 881 it should be ShaderDispatch, CirclesHandle, TextResolution/8, TextResolution/8,
1. 

Now let's add some randomisation to the size and positioning of the circles. 
In the shader use int2Center, int2, random2, floatId.x, times floatTextResolution, intRadius = intRandom,
floatId.x, times 30. The random and random2 functions are already included in the template.
It uses a simple sign-based pseudo-random technique and a seed value. For each pass value it will always return the same value, hence it's not a truly random function, but it will suffice  for our purposes. 

Now change the numThreads line to 32.1.1 and run the program. You now  get 32 circles. 

In the C# script change the parameter pass to dispatchKernel method to  10. Now run in the program you get 320 circles. 10*1*1*32*1*1=320. For the last step we'll  pass the time value. 

In the shader add float Time where you declare variables. Then in the circles  kernel add plus Time in the value passed to the random2 function. 

Finally in the C# script add shader.setFloat timeTime.time. Running the program now you get a randomisation of   the circles, but it would be much better if we could control the motion of the circles.
[00:08:41.600 --> 00:08:48.020]   More like this. That's where buffers come in, and that's the topic for the next video.
[00:08:48.020 --> 00:08:49.040]   Catch you in a minute.

# P7.-002-The-joy-of-buffers

[00:00:00.000 --> 00:00:14.720]   The Joy of Buffers.
So far in this course we've looked at passing data from the CPU, a C# script in other words, to the GPU, a compute shader, using the methods setInt, setFlow, setVector and setTexture.
But what if you want to set a block of data other than a texture?
In this video we're going to look at how useful buffers are for many situations.

[00:00:40.940 --> 00:00:46.360]   Open the scene buffer Joy in the start project, basically where we got to in the previous video.
[00:00:47.560 --> 00:00:53.600]   The real magic of using buffers is we can populate them with any data we choose.
It could be a buffer of floats, float3s, or it can be, as you'll see in this example, custom data.

[00:01:02.080 --> 00:01:08.080]   Open the file "BufferJoy.cs" in Visual Studio, you'll find it in the scripts folder. And this is the script component added to the quad that is handling the CPU side of things.
It is this script that needs to create and populate the CPU data.    Then create a compute buffer and copy the array data to this.    We then copy this to the GPU. 
But we're getting ahead of ourselves.

[00:01:29.120 --> 00:01:33.760]   The first thing we need to do is create a struct to hold an individual instance of the data we're going to use to control the motion of the circles.
Enter struct Circle, public Vector2 Origin, public Vector2 Velocity ,public Float Radius.
And after the count line add circle Array circledata, computeBuffer buffer.
The array of circles will be the CPU data and buffer the GPU version.

[00:02:02.320 --> 00:02:05.920]   Notice in the Start() method we call initData. At the moment all this function does is find the handle of the certled kernel in the shader  instance.
We're going to use this method to create our certled data and pass it to the buffer.

Enter uint ThreadGroupSizeX shader getKernelThreadGroupSizes certlesHandle outThreadGroupSizeX out_out_intTotal=int
ThreadGroupSizeX times count certledata=new certledTotal
FloatSpeed=100 FloatHouseSpeed=speed*0.5f
FloatMinRadius=10.0f FloatMaxRadius=30.0f
FloatRadiusRange=maxRadius-minRadius For int i=0, i<Total, i++
CircleCertle, certledata i CertleOrigin.x RandomValue*TextResolution
CertleOrigin.y=RandomValue*TextResolution CertleVelocityX=RandomValue*Speed-HalfSpeed
CertleVelocityY=RandomValue*Speed-HalfSpeed CertleRadius=RandomValue*Radius+minRadius
Certledata i=Certle. 

Here we use the compute shader method GetKernelThreadGroupSizes to find out what has been set in the shader for the x value.   
In this kernel we have the y and z to 1. The ThreadGroups are all in the x dimension.
We need this value and the count value to determine the total number of certles that we are going to draw.
In this example ThreadGroupSizeX is 32 and counts 10, giving a total of 32*10=320 circles.

We use this value to create an array of Circle structs.


[00:04:11.680 --> 00:04:16.840]   Then we set up some useful variables to allow us to populate this array.
Speed is twice the maximum distance in pixels, a circle can travel in a second.
HalfSpeed is simply half this value.
Min and max radius are the minimum and maximum sizes for each circle, and the range is max-min radius.

The for loop iterates through the certles array and sets up the starting position, the velocity in the x and y directions and the radius.


[00:04:44.000 --> 00:04:48.760]   Before we can pass this data to the shader we need to add some code to it.
On "BufferJoy.compute" from the shader folder and add struct Circle, float2 Origin, float2 Velocity,
float Radius, structured BufferCircle CircleBuffer.
Here we reproduce the Circle struct, where we use a Vector2 we use a float2, but otherwise  it's identical.
Then we declare a structured buffer using this struct.  Great!

[00:05:16.400 --> 00:05:26.480]   Now back to the C# script and the init shader method, add int stride = 2+2+1 * sizer float  buffer = newComputeBuffer certledata.length stride buffer.setData certledata  shader.setBuffer certlesHandle certlesBuffer buffer 

[00:05:40.800 --> 00:05:45.000]   First we need to calculate the byte size of the certle struct.
It contains two Vector2 and a float.   A Vector2 contains two floats, so the size is 2+2+1 times the byte size of a float, which  is actually 4, but we can use the sizeof function to get this value.

[00:06:02.300 --> 00:06:07.800]   When we create a compute buffer we use the array size of our CPU data array and the byte size of each element in the array.    Then we need to populate this buffer with data, which we do using the setData() method of a compute buffer instance.
Finally we need to pass this buffer, which is now on the GPU, to the shader.

[00:06:23.840 --> 00:06:31.080]   At this stage you have two sets of data, one on the CPU and another on the GPU.
Although they contain the same data, they're not pointers to the same batch of memory.
In fact the slowest part of using a compute shader is often passing data between the CPU and the GPU.
Always keep the data passed to the smallest size possible and avoid passing data unnecessarily.


[00:06:52.060 --> 00:06:56.440]   We now have a set of certle elements that we can use in our kernel.
Change the assignment of center and radius to int2Center = int2 certlesBuffer id.x.origin
+ certlesBuffer id.x.velocity * time intRadius = intCertlesBuffer id.x.radius

Our threads are set up to be one-dimensional.  From id.x = 0 to id.x = 319, we can use id.x as an index into the certlesBuffer.  The position of the center is given by the origin + velocity * time.
[00:07:36.920 --> 00:07:42.660]   If you run the program now, eventually all the certles will leave the screen.
We need a way to respawn the certle if it's off-screen. 

[00:07:46.400 --> 00:07:53.560]   Here's a super simple way, just add "while center.x is greater than text resolution,
[00:07:53.560 --> 00:08:01.920]   center.x -= text resolution", then copy this line and set "less than 0 += text resolution"
[00:08:01.920 --> 00:08:04.960]   and copy both lines changing the x value to y.
[00:08:04.960 --> 00:08:10.640]   If the center is off to the right or top, then we repeatedly subtract text resolution
[00:08:10.640 --> 00:08:17.080]   from the x or y value until the value is in the range 0 to text resolution.
[00:08:17.080 --> 00:08:22.660]   If the center is off to the left or bottom, then we add text resolution, again until x
[00:08:22.660 --> 00:08:28.660]   and y are in the desired range, making the certle visible on the texture.
[00:08:28.660 --> 00:08:34.280]   The techniques you learnt in this video are crucial to almost all compute shaders.
[00:08:34.280 --> 00:08:41.060]   One setting up a custom struct, two creating a CPU-based array of these, three creating
[00:08:41.060 --> 00:08:48.580]   a GPU block of memory to pass these values to, and four populating the GPU memory using
[00:08:48.580 --> 00:08:51.320]   the CPU array.
[00:08:51.320 --> 00:08:57.240]   What we haven't done so far is allow the GPU to write to this memory buffer and then return
[00:08:57.240 --> 00:08:59.760]   the values to the CPU.
[00:08:59.760 --> 00:09:03.040]   And that's exactly what we'll do in the next video.
[00:09:03.040 --> 00:09:06.120]   Keep watching as we create some orbiting stars.

# P8.-003-Orbiting-stars


[00:00:00.000]   In this video we are going to create this swarm of orbiting stars. The intention of this course isn't to explain in detail how to set up a Unity scene. This example uses a prefab. I'm assuming you understand about creating and using prefabs in Unity. 
If not  then you really need to do a foundation level course on Unity before you continue. 
Remember this course is for intermediate and advanced users. 
Okay, with that caveat out of the way let's continue. Open the scene orbiting stars and take a look at the empty game object.

[00:00:52.840] Notice this has the script "OrbitingStars.cs" attached. This has the property star count set at 1000.   The shader OrbitingStars assigned as the property shader and the prefab star  assigned as the property prefab.  If you run the program as is you'll be singularly unimpressed.


[00:01:13.440]   But in the next few minutes we're going to take this apparently single star and turn  it into this orbiting swarm. The aim is to use the GPU to position all the stars and  move them in an orbit. 

As a first step let's define the variables we'll use to store the data on the GPU and receive this data on the CPU. 
Add Compute Buffer, Result Buffer, Vector3 Array, Output to the list of properties. 

Next we need to define some GPU memory to store the data. 
In the start method add Result Buffer = New ComputeBuffer *Count Size of Float * 3 Shader.setBuffer KernelHandle,
 Result ResultBuffer Output = New Vector3 *Count.

In the previous video we defined a StructuredBuffer. That's what you want when you're only reading from the buffer. 
But in this example we're writing to the buffer. For that usage we need an RWStructuredBuffer. 
In the "OrbitingStars.compute" file, enter RWStructuredBuffer<float3> Result. Notice it's defined as of type float3 which matches the GPU based output array of type Vector3. 
Recall that this is effectively  a Float3 type. When we create the buffer we use a Stride Size of the Size of a Float * 3.

You can safely run the program now, but you'll see no changes, just a seemingly solitary  star in the centre of the screen. 

The next step is to position each star using the Compute  Shader. 
In the orbiting star kernel add Float3SineDIR = NormalizeRandom3 id.x - 0.5
Float3Vec = NormalizeRandom3 id.x + 7.1393 - 0.5
Float3CosDIR = NormalizeCrossSineDIR Vec
FloatScaleTime = Time * 0.5 + Random(id.x) * 7.12.131234
Float3Pos = SineDIR * SineScaleTime + CosDIR * CosScaleTime
Result id.x = Pos * 2. There's a lot going on there, let's take it a bit at a time.

[00:03:58.720]   With all the use of random you might be wondering why the result is smooth and not wild.
Remember for each value passed to the random function it will always return the same value.

The first line where we set the SineDIR variable uses the Random3 function to create a Random3 component vector. 
Because we use Frac in the Random function, each component of this vector will be in the range 0 to 1.  Frac returns the right side of the decimal point of a float value.   So Frac 10.3649 = 0.3649. 
Using Frac helps randomize the value By subtracting 0.5 from this Float3 vector, each component will have a value in the range  -0.5 to 0.5. 

We create another vector as the variable Vec, using a different value passed  to the Random3 function. Using 7.1393 results in a value that is unlikely to be near parallel with  the SineDIR vector. 

When using random values generated using the Sine method, the return value will repeat every 2 pi, because the Sine function repeats every 2 pi. Sine x is the same as Sine  x + 2 pi. Adding a value that is dissimilar to 2 pi gives the most varied results.
The purpose of the variable Vec is to create a vector that is at right angles to SineDIR.   We can do this using the cross product of two vectors. Can you work out what the cross product of the x and y axes would be?   Pause the video now if you need time to think.

[00:05:43.280]   Yes, it's the z axis. The z axis is at right angles to both the x and y axes.

The vectors sineDIR and vec are unlikely to be at right angles to each other, but the cross product of these two is guaranteed to be at right angles to both of them. Then we create a scaled and randomized version of the time variable that is passed to the shader from the CPU each frame update. It only remains to define a position. 
We use the classic method to position an object on a circular orbit using a sine value and a cos value. A circle can be drawn using sine and cos as the passed angle value varies from 0 to 2 pi. Here we multiply the value by the vectors to position our circle in 3D space. Since the sineDIR and cosDIR range are between plus and minus 0.5, we scale this position value up to be in the range plus or minus 1 by multiplying it by 2. 


So now if we update the time variable and call the shader the correct number of times,the result buffer will contain the positions of all our stars. Add this to the update method.

[00:07:01.280 --> 00:07:10.480]   shader.setFloat(time, time.time) shader.dispatch("Kernel Handle" group size x, 1, 1)

[00:07:10.480]   If you ran the program you would be disappointed. So far we've only calculated where they should be,
not actually positioned them, and you may get an error message because we've not cleared the  buffer. Let's fix that first. Add this code void on destroy resultBuffer.dispose(). 


Our next step is to get the data from the GPU and use it to actually position the stars. 
Remember there's the computeBuffer method getData() which can transfer data to a CPU array 
and remember all the star instances are stored in the transform array stars. 
As a little challenge see if you can
1) get the data from the GPU. We created a Vector3 array called output to store this data.
2) position each star using the retrieve data. Pause the video now and give it a try.
How did you do? I hope you didn't feel it was too hard a challenge. 
My solution is resultBuffer.dispose().

getData() output for int i = 0, i < stars.length, i++, stars i.localPosition = output i.


[00:08:27.920]   Now running the program gives a sphere of orbiting stars. 

Now you know how to pass a StructuredBuffer that you can overwrite to the shader and how to retrieve this so the CPU can work with it.
I added a Bloom post-processing filter to make it a little more dynamic.
More about post-processing in the next section.

But before that I think it's time to make some noise. See you in a minute.

# P9.-004-Using-noise-in-the-shader

[00:00:12.000 --> 00:00:15.000]   Using noise in the shader.
Noise is a great way to add naturalism to your shader.
In real life there's a lot of noise around.
So what is noise? I don't mean you're going to hear it.
[00:00:26.000]   Noise is making something that would otherwise appear to be a flat colour, appear a bit less than perfect.
Surprisingly you can use noise in your shaders for so many things. 
You can use it to make something a bit dirty,but you can also use it to create wood, or fire, or any of thousands of useful things.
Take a look at the scene "SimpleNoise" in Unity.

[00:00:51.000]   If you look at the shader being used in Visual Studio it's also Simple Noise,
and the script on the quad, you've guessed it, it's Simple Noise.

In the shader script we have the simplest noise possible.
[00:01:04.000 --> 00:01:08.000]   We simply use a popular random function.
[00:01:08.000 --> 00:01:13.000]   If you're wondering what those magic numbers are about, 12.9898 etc,
[00:01:13.000 --> 00:01:19.000]   the numbers are chosen to maximise the randomness and minimise the banding.
[00:01:19.000 --> 00:01:24.000]   Try changing them all to 1, and you immediately see very obvious banding.
[00:01:24.000 --> 00:01:30.000]   Ramping the final multiple C up gives a large number of diagonal lines,
[00:01:30.000 --> 00:01:35.000]   and you can change the slope of the lines by adjusting the A and B values.
[00:01:35.000 --> 00:01:38.000]   But for randomness you want there to be no divisor,
[00:01:38.000 --> 00:01:41.000]   because where there is you're going to see banding.
[00:01:41.000 --> 00:01:45.000]   Let's add a seed value to our random function.
[00:01:45.000 --> 00:01:49.000]   Change the random function like this, float seed.
[00:01:49.000 --> 00:01:57.000]   Now, when we call it, use the time variable, so change the call to random by adding time.
[00:01:57.000 --> 00:01:59.000]   At the moment we don't see any change.
[00:01:59.000 --> 00:02:06.000]   Going back to the random function, add plus seed to the value returned from the dot function.
[00:02:06.000 --> 00:02:09.000]   Then press the play button.
[00:02:09.000 --> 00:02:13.000]   The result, each time the screen updates we get a different result,
[00:02:13.000 --> 00:02:17.000]   given the appearance of an old fashioned TV screen showing noise.

[00:02:17.000 --> 00:02:21.000]   All very interesting, but really, where's this going?
[00:02:21.000]   Totally random noise has a limited value. In the early 80s, Ken Perlin was commissioned to create better textures for the film Tron, winning an Oscar for his work. His solution was to create a smoothly varying quantity with randomness in the return value. But as the X and Y components change, the value changes gently.

[00:02:44.000]   Noise is used so often in shaders that it's useful to have a library of functions for generating the values.
[00:02:51.000 --> 00:02:55.000]   There's a great library available at this address.
This has been converted into an HLSL file by LexDRL, and I've added a couple of additional items.  You'll find the file in the shaders folder.


[00:03:06.000 --> 00:03:09.000]   Take a look at the scene ProceduralWood.
[00:03:09.000 --> 00:03:12.000]   The template has a number of properties.
[00:03:12.000 --> 00:03:19.000]   A light colour, a dark colour, frequency, noise scale, ring scale and contrast.
[00:03:19.000 --> 00:03:22.000]   We're going to use these values to create a wood texture.
[00:03:22.000 --> 00:03:25.000]   The first step is to add our noise functions.
[00:03:25.000 --> 00:03:30.000]   Enter #includeNoiseSimplex.cgink.
[00:03:30.000 --> 00:03:33.000]   Now we can use some great noise functions.
[00:03:33.000 --> 00:03:39.000]   Let's use snoise. Enter float n = snoise pos.
[00:03:39.000 --> 00:03:43.000]   And update delta, delta = n.
[00:03:43.000 --> 00:03:46.000]   Not exactly wood, but there's something there.
[00:03:46.000 --> 00:03:49.000]   Let's make use of the other properties.
[00:03:49.000 --> 00:03:54.000]   Enter float ring = frac noise scale times n,
[00:03:54.000 --> 00:04:00.000]   float delta = pow ring ring scale + n.
[00:04:00.000 --> 00:04:04.000]   That looks more like it. If you want more obvious lines,
[00:04:04.000 --> 00:04:11.000]   then change the code adding ring times equals contrast times 1 - ring.


[00:04:11.000 --> 00:04:14.000]   We're using noise to create a wood texture.  Try playing with the property values to get a feel for how you can use this as a wood shader.   
* ringScale allows you to control the size of the ring lines.
* noiseScale impacts the size of the shader. 
And contrast allows you to adjust the contrast between the light and dark colours.


The scene ProceduralMarble is a marble shader.


[00:04:36.000 --> 00:04:39.000]   Here again we're using the noise functions.  This time the famous Perlin function, named after Ken Perlin.  This takes an X and Y value and returns a float.
Scale is important.
[00:04:50.000 --> 00:04:56.000]   To see the basic Perlin function working, press the U key when the game is playing.
[00:04:56.000 --> 00:04:59.000]   Now you can see the output more clearly.
[00:04:59.000 --> 00:05:05.000]   Try adjusting the scale value. See how you need large values to see obvious noise.
[00:05:05.000 --> 00:05:10.000]   In the marble creation we run the Perlin function three times,
[00:05:10.000 --> 00:05:13.000]   building up the final noise value.
[00:05:13.000 --> 00:05:16.000]   We use this value to generate the final colour.
[00:05:16.000 --> 00:05:20.000]   Using the sine function to blend the green and blue channels.
[00:05:20.000 --> 00:05:25.000]   So far we've stayed away from geometry in the shaders we've been considering.
[00:05:25.000 --> 00:05:28.000]   Let's address that in the next video.
[00:05:28.000 --> 00:05:31.000]   So quick pause and I'll see you in a minute.

# P10.-005-Mesh-deformation

[00:00:00.000 --> 00:00:15.000]   Mesh Defamation
[00:00:15.000 --> 00:00:23.000]   In this video we are going to use a compute shader to transform a cube into a sphere and back again.
[00:00:23.000 --> 00:00:28.000]   Open the scene Mesh Deform from the scenes folder in the start project.
[00:00:28.000 --> 00:00:37.000]   In Visual Studio open Mesh Deform.cs from the scripts folder and Mesh Deform.compute from the shaders folder.
[00:00:37.000 --> 00:00:43.000]   Running the program will be disappointing as in its current state it does exactly nothing.
[00:00:43.000]   If we look at the cube you will see it is not the default cube that Unity creates.
Instead it is a subdivided cube I created using the free 3D creation program Blender.

[00:00:55.000]   If you are a lone developer who needs to create assets then I highly recommend Blender as a great accompaniment to Unity. Unity natively imports Blender scene files.
[00:01:07.000 --> 00:01:15.000]   As you update the Blender file Unity will update the meshes stored as Blender files in your Unity assets folder.

[00:01:15.000]   The aim of our shader will be to mix between placing the vertex at a point that is radius length from the centre and the model position of the vertex.
[00:01:26.000]   As a first step we need to pass the mesh data to the GPU.
In the MeshDeform.cs script we need to define a struct to hold the data for a vertex.
[00:01:36.000 --> 00:02:05.000]   We have added a constructor method to the struct.
[00:02:05.000]   But the data in the struct is still only two Vector3s.
In the Compute shader can you define a struct to match the C# one?
[00:02:15.000 --> 00:02:19.000]   Pause the video and give it a try.
[00:02:19.000 --> 00:02:21.000]   How did that go?
[00:02:21.000]   My solution is struct vertex, float3 position, float3 normal.
Nice and simple. No constructors or public and private properties. And a Vector3 maps to a float3.
[00:02:36.000 --> 00:02:42.000]   Now back in the C# script we need to get the vertex data from the cube mesh.
 Enter vertex array vertex array.
Vertex array initial array.
Compute buffer vertex buffer.
Compute buffer initial buffer.

[00:02:55.000]   The vertex array will store the vertex positions to display.
The initial array will store the modelled positions.
[00:03:03.000 --> 00:03:06.000]   Notice in the start method we call initData.
[00:03:06.000 --> 00:03:10.000]   Looking at this method it gets the component mesh filter.
[00:03:10.000 --> 00:03:17.000]   A mesh filter has the property mesh, which gives us access to the necessary vertex data.
[00:03:17.000 --> 00:03:25.000]   After getting a mesh filter we call the class methods initVertexArrays and initGPUBuffers.
[00:03:25.000 --> 00:03:28.000]   At the moment both these methods are empty.
[00:03:28.000 --> 00:03:31.000]   Let's add code to the first one.
[00:03:31.000 --> 00:03:40.000]   In the initVertexArrays method add vertex array equals new vertex mesh.vertex.length.
[00:03:40.000 --> 00:03:44.000]   Then copy it, calling the array initialArray.
[00:03:44.000 --> 00:03:50.000]   For int i = 0, i < vertex array.length, i++.
[00:03:50.000 --> 00:03:58.000]   vertex v1 = new vertex mesh.vertices(i), mesh.normals(i).
[00:03:58.000 --> 00:04:01.000]   vertex array i = v1.
[00:04:01.000 --> 00:04:08.000]   Then copy those two lines and replace v1 with v2 and vertex array with initial array.
[00:04:08.000 --> 00:04:13.000]   First we set up the arrays to be sized to match the vertices array.
[00:04:13.000 --> 00:04:19.000]   Then we iterate over the arrays creating a vertex using the constructor method we created.
[00:04:19.000]   At this point the initial array and the vertex array contain arrays of vertex instances.
At each index the values are the same, but the memory destination is not the same.
If we change vertex array 0 it would have no effect on initial array 0.
[00:04:37.000 --> 00:04:44.000]   Now we need to switch attention to the other method, initGPUBuffers. Add this code.
[00:04:44.000 --> 00:04:57.000]   vertexBuffer = newComputeBuffer vertexArray.length, sizeOfFloat * 6, vertexBuffer.setData, vertexArray.
[00:04:57.000 --> 00:05:02.000]   Then copy those two lines, replacing vertex with initial.
[00:05:02.000 --> 00:05:07.000]   shader.setBuffer, kernelHandleVertexBuffer, vertexBuffer.
[00:05:07.000 --> 00:05:13.000]   shader.setBuffer, kernelHandle, initialBuffer, initialBuffer.
[00:05:13.000 --> 00:05:24.000]   And in the shader add, rwStructuredBuffer, vertex, vertexBuffer, structuredBuffer, vertex, initialBuffer.
[00:05:24.000 --> 00:05:33.000]   Notice that the initial buffer is a structured buffer, not an rwStructuredBuffer. It will be read only by the shader.
[00:05:33.000]   Now we want to write the code to blend between the initial buffer and a point at radius length from the centre of the cube.
[00:05:40.000 --> 00:05:49.000]   In the CS main kernel enter, float3InitialPos = initialBufferId.x.position
[00:05:49.000 --> 00:05:57.000]   float3S = float3Normalize(initialPosition * radius * 0.01)
[00:05:57.000 --> 00:06:03.000]   float3Pos = lerp(initialPosition, s, delta)
[00:06:03.000 --> 00:06:11.000]   vertexBufferId.x.position = pos and add radius as a new float property.
[00:06:11.000]   The times by 0.01 is simply because the cube is scaled by a factor of 100 in the scene and this restores it to unit values.
[00:06:21.000]   Back in the C# script notice the call to get vertices from GPU.

[00:06:27.000 --> 00:06:41.000]   Another empty method, add vertexBuffer.getData vertexArray vector3Array vertices = newVector3 vertexArray.length
[00:06:41.000 --> 00:06:45.000]   then copy this, replacing vertices with normals.
[00:06:45.000 --> 00:07:00.000]   For int i = 0, i < vertexArray.length i++, vertices i = vertexArray.i.position, normals i = vertexArray.i.normal
[00:07:00.000 --> 00:07:06.000]   mesh.vertices = vertices, mesh.normals = normals
[00:07:06.000 --> 00:07:13.000]   Before you press play, update the x value of the dispatch call. What value should you use?
[00:07:16.000 --> 00:07:24.000]   The numThreads is simply one for each dimension, so the value should be vertexArray.length 
[00:07:24.000]   If you press the play button your box blends into a sphere and back to a box in a looping cycle.
How is this achieved?
First we take the current position and treating this as a vector we normalise it, that is we set it to a vector of length 1.
Imagine a vector extending from the origin 0,0,0 to the position. This is converted to length 1 and then multiplied by the radius property. Now it's on the surface of a sphere of radius radius. 

The delta value moves smoothly between 0 and 1. It uses the sine function and time.
The sine function returns a value between -1 and 1 and by adding 1 and dividing by 2 we get a smoothly varying value between 0 and 1.
 We use this value to lerp between the initial position and the calculated position S.
That is where a vertex that is projected onto a sphere of radius size would be.
[00:08:24.000 --> 00:08:27.000]   The result? A breathing box.
[00:08:27.000]   But there's a problem. The edges of the cube are still obvious when the mesh is spherical.


[00:08:32.000 --> 00:08:36.000]   We can fix this by adjusting the normal value.
[00:08:36.000 --> 00:08:44.000]   Back in the shader add Float3InitialNormal = InitialBuffer id.x.Normal
[00:08:44.000 --> 00:08:49.000]   Float3SNormal = Normalise InitialPos
[00:08:49.000 --> 00:08:55.000]   Float3Norm = Lerp InitialNormal SNormal delta
[00:08:55.000 --> 00:09:00.000]   VertexBufferId.x.Normal = Norm
[00:09:00.000]   Here we create a normal by using the vertex position because the local origin of the cube is in the middle of the mesh.   A normal on the sphere's surface is simply a normalised version of this initial position.
Then we use the delta value to blend between the cube and sphere normal.
Pressing play and we see the edge disappear as the cube blends into the sphere.
[00:09:26.000 --> 00:09:33.000]   Try adjusting the radius value to see how this makes the sphere bigger or smaller. Great work!
[00:09:33.000 --> 00:09:37.000]   And that completes your introduction to compute shaders.
[00:09:37.000 --> 00:09:41.000]   In the next section we'll look at using them for post-processing.
[00:09:41.000 --> 00:09:46.000]   But before that, a little challenge and a quiz. Catch you in a minute!
[00:09:50.000 --> 00:09:52.060]   you

# P11.-006-Challenge-Draw-a-polygon

[00:00:00.000 --> 00:00:12.000]   [Music]
[00:00:12.000 --> 00:00:13.000]   Challenge
[00:00:13.000 --> 00:00:16.000]   Draw a polygon filled with noise.
[00:00:16.000]   If you own the Scene “Challenge2” in the Start Project Scenes folder,
and “Challenge2.cs” from the Scripts folder,
and “Challenge2.compute” from the Shaders folder,

[00:00:27.000]   in the Shader you'll find it contains a polygon function that takes six parameters.
First the point we're testing to see if it's in the polygon,
then where the centre is in the coordinate space we're using for testing,
then the radius of the maximum circle that would fit inside the polygon.
Parameter 4 is the number of sides to draw.
The fifth parameter allows us to rotate the polygon.
The value is in radians. 

How many radians are there in a full revolution?
 Hopefully you know there are two pi radians.
[00:01:06.000 --> 00:01:11.000]   And finally this function uses the HLSL function SmoothStep.
[00:01:11.000 --> 00:01:15.000]   We've not met this yet in the course, so let me briefly explain it.
[00:01:15.000 --> 00:01:18.000]   SmoothStep takes three parameters.
[00:01:18.000 --> 00:01:25.000]   If we call them min, max and x, then the return value is 0 if x is less than min,
[00:01:25.000 --> 00:01:28.000]   1 if x is greater than max,
[00:01:28.000 --> 00:01:35.000]   otherwise a value between 0 and 1 if x is in the range between min and max.
[00:01:35.000 --> 00:01:38.000]   It's useful for creating smooth transitions.
[00:01:38.000 --> 00:01:41.000]   Here we use it to soften the edge of the polygon.
[00:01:41.000 --> 00:01:48.000]   Using SmoothStep the test point would either be in the polygon and one returned, or outside and zeroes returned.
[00:01:48.000 --> 00:01:54.000]   Using SmoothStep we can create a softened boundary between inside and outside the polygon.
[00:01:54.000]   The function uses the cosine function to vary the length of a vector extending from the centre to the test point.
[00:02:01.000 --> 00:02:04.000]   Now isn't the time to explain it in great length.
[00:02:04.000 --> 00:02:09.000]   If you're interested, there's a video about it in the last section in the course.
[00:02:09.000 --> 00:02:13.000]   For now, just accept, if you pass suitable parameters,
[00:02:13.000 --> 00:02:19.000]   it will return 1 for a test point in the polygon and 0 for one outside.
[00:02:19.000 --> 00:02:25.000]   Using this I want you to add code to the template to draw a polygon filled with noise.
[00:02:25.000 --> 00:02:31.000]   You'll need to add a public sides property to the file challenge2.cs
[00:02:31.000 --> 00:02:36.000]   and write the code for the CS main kernel in the challenge2 compute file.
[00:02:36.000 --> 00:02:39.000]   Notice this file has an include added.
[00:02:39.000 --> 00:02:44.000]   NoiseSimplex.cginc adds several useful noise functions.
[00:02:44.000 --> 00:02:48.000]   For this example use snoise.
[00:02:48.000 --> 00:02:52.000]   You'll find the compute shader has comments to guide your code.
[00:02:52.000 --> 00:03:01.000]   In my solution I blend between the clear colour and the fill colour times noise using the HLSL function lerp.
[00:03:01.000 --> 00:03:04.000]   This takes three parameters, a, b and n.
[00:03:04.000 --> 00:03:07.000]   a and b must be of the same type.
[00:03:07.000 --> 00:03:13.000]   They could be floats, float2s, whatever, but the types need to match.
[00:03:13.000 --> 00:03:18.000]   The return value will be like this.
[00:03:18.000 --> 00:03:23.000]   When n is 0 you'll get a, and when n is 1 you'll get b.
[00:03:23.000 --> 00:03:28.000]   And if n is in the range 0 to 1 you get a blend of a and b.
[00:03:28.000 --> 00:03:34.000]   Use this method to set the colour value using the return value from the polygon function.
[00:03:34.000 --> 00:03:37.000]   Be prepared to spend up to 30 minutes on this challenge.
[00:03:37.000 --> 00:03:44.000]   Please persevere before continuing to the answer.
[00:03:44.000 --> 00:03:47.000]   How did you do? It's difficult.
[00:03:47.000 --> 00:03:51.000]   You need to understand how the parameters of the polygon function need setting
[00:03:51.000 --> 00:03:56.000]   and you need to feel comfortable using the HLSL function lerp.
[00:03:56.000 --> 00:04:01.000]   In the C# script I added public int size equals 6.
[00:04:01.000 --> 00:04:08.000]   And in the int shader method I added shader.setInt size, size.
[00:04:08.000 --> 00:04:13.000]   I decided to rotate the polygon so I added this code to the update method.
[00:04:13.000 --> 00:04:18.000]   shader.setFloat(time, time.time)
[00:04:18.000 --> 00:04:21.000]   That's all that's required for the C# script.
[00:04:21.000 --> 00:04:24.000]   Now we switch to the compute shader.
[00:04:24.000 --> 00:04:36.000]   The kernel code is float2pos = float2 float2id.xy / floatTextResolution -0.5
[00:04:36.000 --> 00:04:41.000]   float2center = 0 floatRadius = 0.15
[00:04:41.000 --> 00:04:51.000]   floatInPolygon = polygon pos center radius size time 0.001
[00:04:51.000 --> 00:04:55.000]   floatNoise = sNoise pos * 100
[00:04:55.000 --> 00:05:03.000]   floatForColor = lerp clearColor fillColor * noise inPolygon
[00:05:03.000 --> 00:05:09.000]   We cast the id.xy value, which is a Uint2, to a float2
[00:05:09.000 --> 00:05:13.000]   and divide it by the TextResolution, casting this to a float.
[00:05:13.000 --> 00:05:16.000]   Then we subtract 0.5.
[00:05:16.000 --> 00:05:25.000]   Now the pos value is in the range plus and minus 0.5, not 00 to TextResolution, TextResolution.
[00:05:25.000 --> 00:05:31.000]   Then we set the center to 00 and radius to 0.15.
[00:05:31.000 --> 00:05:36.000]   We call the polygon function, the edge is set to a very small value.
[00:05:36.000 --> 00:05:42.000]   And the noise value is set using the sNoise method, which takes the float2 value.
[00:05:42.000 --> 00:05:49.000]   Finally we use the lerp function to blend between the clearColor and the fillColor times noise.
[00:05:49.000 --> 00:05:54.000]   Remember the noise value will simply be a float value in the range 0 to 1.
[00:05:54.000 --> 00:06:01.000]   Multiplying fillColor by this value phase the color in or out depending on this value.
[00:06:01.000 --> 00:06:07.000]   Running the program now results in a rotating polygon filled with the noise as required.
[00:06:07.000 --> 00:06:14.000]   And that completes section 2. Just a quick quiz and then it's on to post-processing in section 3.

